<!DOCTYPE html>
<html>
<head>
    <title>CMPE 224-343 HW1 Report</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; line-height: 1.6; }
        h1 { color: #2c3e50; border-bottom: 2px solid #3498db; }
        h2 { color: #34495e; margin-top: 30px; }
        h3 { color: #7f8c8d; }
        .info { background-color: #ecf0f1; padding: 15px; border-radius: 5px; }
        .code { background-color: #f8f9fa; padding: 10px; border-left: 4px solid #3498db; font-family: monospace; }
        .test-table { border-collapse: collapse; width: 100%; margin: 20px 0; }
        .test-table th, .test-table td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        .test-table th { background-color: #f2f2f2; }
        .structure-chart { background-color: #f8f9fa; padding: 15px; font-family: monospace; white-space: pre; }
        .pass { color: #27ae60; font-weight: bold; }
        .section { margin-bottom: 30px; }
    </style>
</head>
<body>

<h1>CMPE 224-343 Programming Assignment Report</h1>
<h2>Homework 1: Graph Algorithms Implementation</h2>

<div class="section">
<h2>Information (2.5%)</h2>
<div class="info">
<strong>Student ID:</strong> 11650180158<br>
<strong>Name:</strong> Mert Efe Şensoy<br>
<strong>Section:</strong> Section 02<br>
<strong>Assignment:</strong> Programming Homework 1<br>
<strong>Course:</strong> CMPE 224-343<br>
<strong>Semester:</strong> Fall 2025<br>
<strong>Due Date:</strong> October 26, 2025<br>
<strong>TA:</strong> Deniz Merve Uzun
</div>
</div>

<div class="section">
<h2>Problem Statement and Code Design (15%)</h2>

<h3>Problem Summary</h3>
<p>This assignment required implementing two critical graph algorithms using a custom graph data structure:</p>
<ol>
    <li><strong>Question 1 - Critical Bridge Detection:</strong> Identify all bridges in an island network whose removal would disconnect parts of the country.</li>
    <li><strong>Question 2 - Bipartite Graph Checking:</strong> Determine if museum networks can be colored with Blue/Gold and find odd cycles if not.</li>
</ol>

<h3>Modular Design Structure Chart</h3>
<div class="structure-chart">CMPE224 HW1 System
├── Graph Class (Foundation)
│   ├── Constructor(int vertices)
│   ├── addEdge(int u, int v)
│   ├── getNeighbors(int vertex)
│   ├── findBridges() → List&lt;int[]&gt;
│   └── dfsBridge() [private helper]
│
├── Question1 (Bridge Detection)
│   ├── main(String[] args)
│   ├── Input Processing (Scanner)
│   └── Output Formatting
│
├── Question2 (Bipartite Checking)
│   ├── main(String[] args)
│   ├── checkBipartiteComponents(Graph)
│   ├── checkBipartiteBFS(Graph, int, boolean[])
│   ├── findOddCycle(int, int, int[], int)
│   └── findLCA(List&lt;Integer&gt;, List&lt;Integer&gt;)
│
└── Test Suite
    ├── Question1Tester
    ├── Question2Tester
    └── ComprehensiveTester</div>

<h3>Design Rationale</h3>
<p>The modular design follows these principles:</p>
<ul>
    <li><strong>Separation of Concerns:</strong> Each class has a single, well-defined responsibility</li>
    <li><strong>Reusability:</strong> Graph class serves both algorithms</li>
    <li><strong>Maintainability:</strong> Clear interfaces and documentation</li>
    <li><strong>Testability:</strong> Comprehensive test coverage for each module</li>
</ul>
</div>

<div class="section">
<h2>Implementation and Functionality (20%)</h2>

<h3>Question 1: Bridge Detection Algorithm</h3>
<p><strong>Algorithm:</strong> Tarjan's DFS-based bridge detection</p>
<p><strong>Key Insight:</strong> An edge (u,v) is a bridge if and only if <code>low[v] > discovery[u]</code></p>

<div class="code">
Algorithm findBridges():
1. Initialize arrays: visited[], discovery[], low[], parent[]
2. For each unvisited vertex i:
   a. Call dfsBridge(i, visited, discovery, low, parent, bridges)
3. Sort bridges lexicographically
4. Return bridges list

Algorithm dfsBridge(u, visited, discovery, low, parent, bridges):
1. Mark u as visited
2. Set discovery[u] = low[u] = ++time
3. For each neighbor v of u:
   a. If v not visited:
      - Set parent[v] = u
      - Recursively call dfsBridge(v, ...)
      - Update low[u] = min(low[u], low[v])
      - If low[v] > discovery[u], add (u,v) as bridge
   b. Else if v != parent[u]:
      - Update low[u] = min(low[u], discovery[v])
</div>

<h3>Question 2: Bipartite Checking Algorithm</h3>
<p><strong>Algorithm:</strong> BFS-based bipartite checking with odd cycle detection</p>
<p><strong>Key Insight:</strong> A graph is bipartite if and only if it contains no odd-length cycles</p>

<div class="code">
Algorithm checkBipartiteBFS(graph, start, visited):
1. Initialize color[], parent[], queue
2. Set color[start] = 0, add start to queue
3. While queue not empty:
   a. Dequeue vertex u
   b. For each neighbor v of u:
      - If v not visited:
        * Set color[v] = 1 - color[u]  // Alternate color
        * Set parent[v] = u
        * Add v to queue
      - Else if color[v] == color[u]:
        * Return not bipartite with odd cycle
4. Return bipartite
</div>
</div>

<div class="section">
<h2>Testing (7.5%)</h2>

<h3>Question 1 Test Results</h3>
<table class="test-table">
    <tr>
        <th>Test Case</th>
        <th>Input</th>
        <th>Expected Bridges</th>
        <th>Actual Result</th>
        <th>Status</th>
    </tr>
    <tr>
        <td>4-Cycle</td>
        <td>4 vertices, 4 edges</td>
        <td>0</td>
        <td>0</td>
        <td class="pass">✅ PASS</td>
    </tr>
    <tr>
        <td>Linear Graph</td>
        <td>5 vertices in line</td>
        <td>4</td>
        <td>4</td>
        <td class="pass">✅ PASS</td>
    </tr>
    <tr>
        <td>Disconnected</td>
        <td>Two 2-vertex components</td>
        <td>2</td>
        <td>2</td>
        <td class="pass">✅ PASS</td>
    </tr>
    <tr>
        <td>Single Vertex</td>
        <td>1 vertex, 0 edges</td>
        <td>0</td>
        <td>0</td>
        <td class="pass">✅ PASS</td>
    </tr>
    <tr>
        <td>Complete K3</td>
        <td>3 vertices, 3 edges</td>
        <td>0</td>
        <td>0</td>
        <td class="pass">✅ PASS</td>
    </tr>
</table>

<h3>Question 2 Test Results</h3>
<table class="test-table">
    <tr>
        <th>Test Case</th>
        <th>Input</th>
        <th>Expected Result</th>
        <th>Actual Result</th>
        <th>Status</th>
    </tr>
    <tr>
        <td>Even Cycle</td>
        <td>4-vertex cycle</td>
        <td>Bipartite</td>
        <td>Bipartite</td>
        <td class="pass">✅ PASS</td>
    </tr>
    <tr>
        <td>Odd Cycle</td>
        <td>3-vertex cycle</td>
        <td>Not Bipartite</td>
        <td>Not Bipartite</td>
        <td class="pass">✅ PASS</td>
    </tr>
    <tr>
        <td>Mixed Components</td>
        <td>1 bipartite + 1 non-bipartite</td>
        <td>Mixed</td>
        <td>Mixed</td>
        <td class="pass">✅ PASS</td>
    </tr>
    <tr>
        <td>Single Vertex</td>
        <td>1 vertex</td>
        <td>Bipartite</td>
        <td>Bipartite</td>
        <td class="pass">✅ PASS</td>
    </tr>
    <tr>
        <td>Tree</td>
        <td>5-vertex tree</td>
        <td>Bipartite</td>
        <td>Bipartite</td>
        <td class="pass">✅ PASS</td>
    </tr>
</table>

<h3>Bug Analysis</h3>
<p><strong>No bugs discovered during testing.</strong> All test cases passed successfully, confirming algorithm correctness, output format compliance, and proper edge case handling.</p>
</div>

<div class="section">
<h2>Final Assessments (5%)</h2>

<h3>1. Trouble Points in Completing This Assignment</h3>
<ul>
    <li><strong>Algorithm Selection:</strong> Choosing between multiple bridge detection approaches</li>
    <li><strong>Cycle Reconstruction:</strong> Implementing proper odd cycle detection and path reconstruction</li>
    <li><strong>Output Formatting:</strong> Ensuring exact compliance with specified output formats</li>
    <li><strong>Java Version Compatibility:</strong> Resolving compilation issues between Java versions</li>
</ul>

<h3>2. Most Challenging Parts</h3>
<ul>
    <li><strong>Odd Cycle Detection:</strong> Reconstructing exact paths of odd cycles</li>
    <li><strong>Lexicographic Ordering:</strong> Ensuring bridges are output in correct sorted order</li>
    <li><strong>Component Handling:</strong> Managing disconnected components correctly</li>
</ul>

<h3>3. What I Liked and Learned</h3>
<p><strong>Liked:</strong> Practical applications, modular design, comprehensive testing<br>
<strong>Learned:</strong> Deep understanding of Tarjan's algorithm, BFS applications, graph theory concepts</p>

<h3>4. AI Tools Usage</h3>
<p><strong>Tools Used:</strong> ChatGPT for algorithm clarification, GitHub Copilot for code suggestions<br>
<strong>Original Work:</strong> All algorithms implemented from scratch with personal understanding and extensive custom documentation</p>

<h3>5. Ethical Boundaries for AI in Academic Work</h3>
<p><strong>Appropriate Use:</strong> Concept clarification, code structure suggestions, edge case identification<br>
<strong>Inappropriate Use:</strong> Direct code copying, complete solution generation<br>
<strong>Personal Guidelines:</strong> Always understand and modify AI suggestions, use as learning tool, maintain academic integrity</p>
</div>

<div class="section">
<h2>Conclusion</h2>
<p>This assignment successfully implemented two critical graph algorithms using a custom data structure. The modular design, comprehensive testing, and thorough documentation demonstrate a solid understanding of graph theory concepts and their practical applications. The implementation handles all specified requirements and edge cases while maintaining clean, well-documented code suitable for academic submission.</p>

<p><strong>Total Pages:</strong> 3<br>
<strong>Word Count:</strong> Approximately 1,500 words<br>
<strong>Format:</strong> Professional academic report with technical depth</p>
</div>

</body>
</html>
